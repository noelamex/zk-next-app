{"noir_version":"1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663","hash":"11192873944600383430","abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"hashed","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"tZjfTis5DIffpddcxHb+8iqrFSpQjipVBfXASivEu+9kxt8ULmbUbXVuSBo7H4mTn532c/O8e/z49bA/vrz+3tz/9bl5PO0Ph/2vh8Pr0/Z9/3ocRj+/7jZ8fHg/7XbD0OabfZj1tj3tju+b++PH4XC3+Wd7+Bidfr9tj2P7vj0N1nC32R2fh3YAvuwPu977ujvPDstTJUefLLXM09PP+bI8P1fz+SWc/31KP+br8ny15PO16Hl+/DHfVtbfrLCBlr/tIF9K0KDKEoLFJUJaJsRUCMLQrVcRWoOQQ76GkCXPBK1XxaHMcRCN1xAknQllcReych0tR7Zhefk41xF2CWJ1H407pRra4iLs5iuxjrjoTqwibr8Uam0ORZNrCCYCwWJa3Ea9/VLUP3opYpr3EfPicehKrixSSLZF6jlbSr0coXOyKmqLiNV9zBlbU7wqEinN8khVryHkmuesH+0qwqyvawlV5spTvx3G/yEEu41gcr6VEpf1GW5ONOuIixLNKuLmRGND9SYUetWlMhPeQWbLddzSzYlmHXFrojFLad7HCqHefinq7Zei/tFLYZWcazEs1o6oNx/pOuKiIw1rT6s5Uaj8eGT/PXzaPu1PP74WbMKQ3e82srkfoqvjXxte2nebOI6ncSSPI2UcqeNIG0ckTI1MjU4oGz0kToNpGszT4MCQoS5J9bZNrQ6gniJV+reEoVUfNx+PPp76toY2e1u8rd62XvmHLYReL4ZWpnFTb83t0e3OM+dZcXt1e5vGY/BWJnvUyR7Nx6O3zovZ/Yr7+fqi81KY7Ekme/L1Jecl56Xkftn9fL/Jecl52XnZedl52XnZedl52XnZedl52eNXPH7F41ecV5xXnFecV5xXnFecV5xXnVedV51X/Tyqn0f1+FU/j+q8Wt2vTX7Nz6M5r+lkb+Z2X19zXnNe8/Ntfr7N4ych0BE6jpTgTAkRU6KT6RScK86QBbJAFsgCWSALZIEshU5llsdAFLJCVqXjcRWNOENGOqKsWVmzsmaDjH4EAQkKEiQkaEgQkaAiQUaCjgQhSYQcIUfIETJqkgg5Eo1INCLRSJATZEQlqEpGWfVZo67GWZBRliTICXKGnCEjL0FfgsAEhQkSEzQmiExQmSAzQWeC0ASlSWHNhTUX1ozaBLkJehMEJyhOkJxUyBVyhYzsBN1JhVwhN8hoTxrkBhn5SSMajWg0yA0yGtTgSUyDZzENisnoRDoJ54wztSBQDNCgokEVz98qnsBVIKNBRYMqGeeCM2SBrKxZWTMaVIWskOfqpZAV8lzA0KAaZIOMBtUgG2Q0qAbZIBtkNKhoUKlmSjlT6plS0BQNKhrUWJhVmQUZDSoa1OS5TpPnOqW0aYKMBhUNKuVNk986zX7rFA0qGlQ0qDninHCGjAY1V3xc3VpYMxpUNKjFM5KWiDNrLvMDhGgUolGIRoWMBrUSjUo0KtGg8ika1Aq5Qq6QKX+KBpUCqFRARYNKDdTG3WjcjTY/m5xs1EELfjcs+N2wrkGT3ol0Uv8C1Tu5v597p2CqmJqbugZHU9fg1FE65s5dg5NzwpQxFUwVU/OOQu4aHJ27BkdnZc1dg5MpYerk1juFTqUzkGPor8WBHPv0rsHR1DU4mQxT7F9gvvqD/LTfPh52/mP7y8fx6dtv7+//vmHh1/m30+vT7vnjtOsP8tE2PNH/Aw==","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use dep::poseidon::poseidon::bn254;\r\n\r\nfn main(secret: Field, hashed: pub Field) {\r\n    // Hash a single Field element with Poseidon over BN254\r\n    let computed = bn254::hash_1([secret]);\r\n\r\n    assert(computed == hashed);\r\n}\r\n","path":"/home/dnoel/zk-next-app/noir/password/src/main.nr"},"54":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/home/dnoel/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"55":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/home/dnoel/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"56":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/home/dnoel/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"expression_width":{"Bounded":{"width":4}}}